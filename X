if _G.UntitledOVRActive then
	if game.CoreGui:FindFirstChild("VRMenu") or game.CoreGui:FindFirstChild("PCMenu") then
		_G.UntitledOVRMenu.Unload()
	end
	_G.UntitledOVRActive = nil
	_G.UntitledOVRMenu = nil
end

_G.UntitledOVRMenu = {}
_G.UntitledOVRActive = true

local testingInRs = false
testingInRs = game:GetService("RunService"):IsStudio()
task.wait(testingInRs and 6.5 or 0.5)

local configVersion = "v2.7.1"
local subscriptionStateText = configVersion
local menuTitle = "Photon"

if not isfolder or not makefolder then
	warn("File system functions not available")
else
	if not isfolder(menuTitle) then makefolder(menuTitle) end
end

function tableToColor3(table)
	return Color3.new(table.R, table.G, table.B)
end

function GithubDirectory(String)
	return "https://raw.githubusercontent.com/Roras520/Lib/refs/heads/main/" .. String
end

local UtilLoader = loadstring(game:HttpGet("https://raw.githubusercontent.com/Number2189/Random/refs/heads/main/UtilityLoader"))()
local Modules = {
	Notifications = UtilLoader.LoadModule("Notifications"),
	ConfigManager = UtilLoader.LoadModule("ConfigManager"),
	EspModule = UtilLoader.LoadModule("EspModule"),
	TimedLoopModule = UtilLoader.LoadModule("LoopManager"),
	Acrylic = UtilLoader.LoadModule("Acrylic"),
}
local notificationLibrary = Modules.Notifications
local notificationSettings = notificationLibrary.GetNotificationSettings()
local configManager = Modules.ConfigManager
local LuneUI = loadstring(game:HttpGet("https://pastebin.com/raw/M51znw9A"))()
local esp = Modules.EspModule
local espConfig = esp.GetConfig()
local timedLoopModule = Modules.TimedLoopModule

local tweenService = game:GetService("TweenService") 
local userInputService = game:GetService("UserInputService")
local virtualInputManager = game:GetService("VirtualInputManager")
local players = game:GetService("Players")
local runService = game:GetService("RunService")
local vrService = game:GetService("VRService")
local httpService = game:GetService("HttpService")
local lighting = game:GetService("Lighting")
local workspace = workspace

local localPlayer = players.LocalPlayer
local localPlayerName = localPlayer.Name
local localCharacter = localPlayer.Character
local localHumanoid = localCharacter:WaitForChild("Humanoid")
local camera = workspace.CurrentCamera

local map = workspace:WaitForChild("Map")
local items = workspace:WaitForChild("Items")
local powerUps = workspace:WaitForChild("PowerUps")

local bodyPositions = {}

local localHead = localCharacter:WaitForChild("Head")
local localTorso = localCharacter:WaitForChild("Torso")
local localRoot = localCharacter:FindFirstChild("Root") or localCharacter:FindFirstChild("HumanoidRootPart")
local localBody = localCharacter:FindFirstChild("Body") or localCharacter:FindFirstChild("Root") or localCharacter:FindFirstChild("HumanoidRootPart")
local localLocoSphere = localCharacter:FindFirstChild("LocoSphere") or localCharacter:FindFirstChild("HumanoidRootPart") or localCharacter:FindFirstChild("Root")
local localRightArm = localCharacter:WaitForChild("Right Arm")
local localLeftArm = localCharacter:WaitForChild("Left Arm")
local rootOrLocoSphere = localCharacter:FindFirstChild("Root") or localCharacter:FindFirstChild("HumanoidRootPart") or localCharacter:FindFirstChild("LocoSphere")

local core = nil
if not runService:IsStudio() then
	core = game.CoreGui
end
local cGui = nil
cGui = runService:IsStudio() and localPlayer.PlayerGui or core
local handOrbs = camera:FindFirstChild("VirtualHands") or localCharacter
local ltp = Vector2.new(0, 0)
local rtp = 0

local vrVariables = {
	Head = localCharacter:FindFirstChild("Head"),
	LeftHand = handOrbs:FindFirstChild("LeftHand") or handOrbs:FindFirstChild("Left Arm"),
	RightHand = handOrbs:FindFirstChild("RightHand") or handOrbs:FindFirstChild("Right Arm")
}

local modStates = {
	SpeedBoostOn = false,
	TSFOn = false,
	TSF2On = false,
	AimbotROn = false,
	AimbotRNewOn = false,
	AimbotLOn = false,
	ChamsOn = false,
	KillFarmOn = false,
	PcAimbotOn = false,
	PcFlyOn = false,
	HandFlyOn = false,
	HandFly2On = false,
	SlowFallingOn = false,
	JumpPowerOn = false,
	FullbrightOn = false,
	GravityChangeOn = false,
	TriggerBotOn = false,
	HeadFlyOn = false,
	GunRgbOn = false,
	AntiModeratorOn = true,
	FreezeAllplayers = false,
	BunnyHopOn = false,
	HealthBarOn = false,
	DistanceOn = false,
	PulseEspOn = false,
	RainbowEspOn = false,
	AimbotRReverseOn = false,
	AimbotRandomizationOn = true,
	RightAimbotPerformantOn = false
}

local settings = {
	PcSpeedBoostSpeed = { min = 1, max = 150, value = 25 },
	AimbotFov = { min = 1, max = 30, value = 3.5 },
	AimAssistSpeed = { min = 0.05, max = 0.95, value = 0.36 },
	RLineTransparency = { min = 0, max = 1, value = 1 },
	LLineTransparency = { min = 0, max = 1, value = 1 },
	ORLT = { min = 0, max = 1, value = 0.3 },
	OLLT = { min = 0, max = 1, value = 0.3 },
	RLineVisible = { value = false },
	LLineVisible = { value = false },
	FlySpeed = { min = 10, max = 200, value = 35 },
	PcAimbotSpeed = { min = 0.01, max = 1, value = 0.5 },
	PcAimbotFov = { min = 20, max = 1000, value = 100 },
	PcFlySpeed = { min = 10, max = 200, value = 50 },
	HandFlyR = { value = true },
	HandFlyL = { value = false },
	ShowFov = { value = true },
	ShowFovWhenAiming = { value = false },
	PcJumpPower = { min = 1, max = 100, value = 16 },
	VRJumpPower = { min = 1, max = 100, value = 5 },
	Gravity = { min = 1, max = 100, value = 32 },
	FovUpdateIntervalRL = { min = 0, max = 0.5, value = 0.07 },
	AimbotLerp = { value = true },
	AimbottargetIndicators = { value = true },
	Fly1Bind = { value = "ButtonR2" },
	Fly2Bind = { value = "ButtonL2" },
	LineLength = { min = 100, max = 2000, value = 1000 },
	WallTransparency = { min = 0, max = 1, value = 0 },
	HeadFlySpeed = { min = 1, max = 20, value = 2 },
	SpeedBoostMaxSpeed = { min = 1, max = 50, value = 18 },
	ModeratorList = {
		value = {
			"ololo999",
			"cat_killur",
			"GrilledSnakeLegs"
		}
	},
	PositionalStrength = { min = 0, max = 10000, value = 750 },
	RotationalStrength = { min = 0, max = 10000, value = 750 },
	RLineColor = { value = Color3.new(1, 0, 0) },
	LLineColor = { value = Color3.new(1, 0, 0) },
	PulsePrimaryColor = { value = Color3.fromRGB(0, 170, 255) },
	PulseSecondaryColor = { value = Color3.fromRGB(0, 255, 170) },
	PulseSpeed = { min = 0.1, max = 5, value = 1 },
	RainbowSpeed = { min = 0.1, max = 5, value = 1 },
	AimbotTargetPart = { value = "Head" },
	VRFovTransparency = { min = 0, max = 1, value = 1 },
	VRFovColor = { value = Color3.fromRGB(255, 0, 0) },
	
	AimbotRandomization = { value = true },
	RandomizationMultiplier = { min = 0.1, max = 2.0, value = 0.8 },
	RightAimbotHitchance = { min = 0, max = 100, value = 85 },
	LeftAimbotHitchance = { min = 0, max = 100, value = 85 },
	RightAimbotPerformantMode = { value = false }
}

local function getSettingValue(key)
	local setting = settings[key]
	if type(setting) == "table" and setting.value ~= nil then
		return setting.value
	elseif type(setting) ~= "table" then
		return setting
	end
	return nil
end

local function validateSettings()
	for key, data in pairs(settings) do
		if type(data) == "table" and data.min and data.max and data.value then
			data.value = math.clamp(data.value, data.min, data.max)
		end
	end
	
	if settings.RightAimbotHitchance and settings.RightAimbotHitchance.value then
		settings.RightAimbotHitchance.value = math.clamp(settings.RightAimbotHitchance.value, 0, 100)
	end
	if settings.LeftAimbotHitchance and settings.LeftAimbotHitchance.value then
		settings.LeftAimbotHitchance.value = math.clamp(settings.LeftAimbotHitchance.value, 0, 100)
	end
end

local targetIndicators = {}

function InMainFolder(String)
	return menuTitle .. "/" .. String .. ".json"
end

configManager.Register("SETTINGS", settings, InMainFolder("settings"))
configManager.Register("MODSTATES", modStates, InMainFolder("modstates"))
configManager.Register("ESPCONFIG", espConfig, InMainFolder("esp"))
configManager.Register("NOTIFICATIONSETTINGS", notificationSettings, InMainFolder("notifications"))

local headDistance = userInputService.VREnabled and 2.2 or -3
local nAng90 = math.rad(-90)

local aimbotFovR = Instance.new("Part", workspace)
aimbotFovR.Name = "aimbotfovr"
aimbotFovR.Transparency = getSettingValue("VRFovTransparency")
aimbotFovR.CanCollide = false
aimbotFovR.CanTouch = false
aimbotFovR.CanQuery = false
aimbotFovR.Massless = true
aimbotFovR.Material = Enum.Material.Neon
aimbotFovR.Color = getSettingValue("VRFovColor")
aimbotFovR.Size = Vector3.new(getSettingValue("LineLength"), getSettingValue("AimbotFov"), getSettingValue("AimbotFov"))
aimbotFovR.Shape = Enum.PartType.Cylinder

local aimbotFovRWeld = Instance.new("Weld", aimbotFovR)
aimbotFovRWeld.Part0 = localRightArm
aimbotFovRWeld.Part1 = aimbotFovR
aimbotFovRWeld.C0 = CFrame.Angles(0, 0, nAng90) * CFrame.new(getSettingValue("LineLength") / 2, 0.47, -0.3)

local aimbotFovL = Instance.new("Part", workspace)
aimbotFovL.Name = "aimbotfovl"
aimbotFovL.Transparency = getSettingValue("VRFovTransparency")
aimbotFovL.CanCollide = false
aimbotFovL.CanTouch = false
aimbotFovL.CanQuery = false
aimbotFovL.Massless = true
aimbotFovL.Material = Enum.Material.Neon
aimbotFovL.Color = getSettingValue("VRFovColor")
aimbotFovL.Size = Vector3.new(getSettingValue("LineLength"), getSettingValue("AimbotFov"), getSettingValue("AimbotFov"))
aimbotFovL.Shape = Enum.PartType.Cylinder

local aimbotFovLWeld = Instance.new("Weld", aimbotFovL)
aimbotFovLWeld.Part0 = localLeftArm
aimbotFovLWeld.Part1 = aimbotFovL
aimbotFovLWeld.C0 = CFrame.Angles(0, 0, nAng90) * CFrame.new(getSettingValue("LineLength") / 2, 0.47, 0)

local rLine = Instance.new("Part", workspace)
rLine.Name = "rlaser"
rLine.Transparency = getSettingValue("RLineTransparency") 
rLine.CanCollide = false
rLine.CanTouch = false
rLine.CanQuery = false
rLine.Massless = true
rLine.Color = type(settings.RLineColor) == "table" and settings.RLineColor.value or (typeof(settings.RLineColor) == "Color3" and settings.RLineColor or Color3.new(1, 0, 0))
rLine.Size = Vector3.new(getSettingValue("LineLength"), 0.01, 0.01)
rLine.Material = Enum.Material.Neon
rLine.Shape = Enum.PartType.Cylinder

local rLineWeld = Instance.new("Weld", rLine)
rLineWeld.Part0 = localRightArm
rLineWeld.Part1 = rLine
rLineWeld.C0 = CFrame.Angles(0, 0, nAng90) * CFrame.new(getSettingValue("LineLength") / 2, 0, -0.3)

local lLine = Instance.new("Part", workspace)
lLine.Name = "llaser"
lLine.Transparency = getSettingValue("LLineTransparency") 
lLine.CanCollide = false
lLine.CanTouch = false
lLine.CanQuery = false
lLine.Massless = true
lLine.Color = type(settings.LLineColor) == "table" and settings.LLineColor.value or (typeof(settings.LLineColor) == "Color3" and settings.LLineColor or Color3.new(1, 0, 0))
lLine.Size = Vector3.new(getSettingValue("LineLength"), 0.01, 0.01)
lLine.Material = Enum.Material.Neon
lLine.Shape = Enum.PartType.Cylinder

local lLineWeld = Instance.new("Weld", lLine)
lLineWeld.Part0 = localLeftArm
lLineWeld.Part1 = lLine
lLineWeld.C0 = CFrame.Angles(0, 0, nAng90) * CFrame.new(getSettingValue("LineLength") / 2, 0, 0.3)

local function speedBoost()
	local success, err = pcall(function()
		if vrService.VREnabled then
			if not rootOrLocoSphere then return end
			
			local moveDirection = localHumanoid.MoveDirection
			if moveDirection.Magnitude > 0 and rootOrLocoSphere.Velocity.Magnitude < getSettingValue("SpeedBoostMaxSpeed") then
				local impulse = moveDirection * 23
				rootOrLocoSphere:ApplyImpulse(Vector3.new(impulse.X, 0, impulse.Z))
			end
		else
			if not rootOrLocoSphere then return end
			
			local Direction = Vector3.zero

			if userInputService:IsKeyDown(Enum.KeyCode.W) then
				Direction += Vector3.new(0, 0, 1)
			end
			if userInputService:IsKeyDown(Enum.KeyCode.S) then
				Direction += Vector3.new(0, 0, -1)
			end
			if userInputService:IsKeyDown(Enum.KeyCode.A) then
				Direction += Vector3.new(-1, 0, 0)
			end
			if userInputService:IsKeyDown(Enum.KeyCode.D) then
				Direction += Vector3.new(1, 0, 0)
			end

			if Direction.Magnitude > 0 then
				Direction = Direction.Unit

				local Movedirworld = (camera.CFrame.RightVector * Direction.X + camera.CFrame.LookVector * Direction.Z).Unit

				rootOrLocoSphere.Velocity = Vector3.new(
					Movedirworld.X * getSettingValue("PcSpeedBoostSpeed"),
					rootOrLocoSphere.Velocity.Y,
					Movedirworld.Z * getSettingValue("PcSpeedBoostSpeed")
				)
			end
		end
	end)
	
	if not success then
		warn("SpeedBoost error:", err)
	end
end

local lastJumpTimeVR = 0
local bunnyHopConnection = nil

local function jumpPower()
	if vrService.VREnabled then
		if userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR3) then
			local CT = tick()
			if CT - lastJumpTimeVR >= 1 then
				if rootOrLocoSphere.AssemblyLinearVelocity then
					rootOrLocoSphere.AssemblyLinearVelocity = Vector3.new(rootOrLocoSphere.AssemblyLinearVelocity.X, getSettingValue("VRJumpPower"), rootOrLocoSphere.AssemblyLinearVelocity.Z)
				else
					rootOrLocoSphere.Velocity = Vector3.new(rootOrLocoSphere.Velocity.X, rootOrLocoSphere.Velocity.Y + getSettingValue("VRJumpPower"), rootOrLocoSphere.Velocity.Z)
				end
				lastJumpTimeVR = CT
			end
		end
	else
		localHumanoid.JumpPower = getSettingValue("PcJumpPower") 
	end
end

local function bunnyHop()
	if not vrService.VREnabled and localHumanoid then
		if not bunnyHopConnection then
			bunnyHopConnection = localHumanoid.StateChanged:Connect(function(old, new)
				if new == Enum.HumanoidStateType.Landed then
					localHumanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end)
		end
	end
end

local function stopbunnyHop()
	if bunnyHopConnection then
		bunnyHopConnection:Disconnect()
		bunnyHopConnection = nil
	end
end

local function pcFly()
	if userInputService:IsKeyDown(Enum.KeyCode.Q) then
		local cameraLookVector = camera.CFrame.LookVector
		rootOrLocoSphere.Velocity = cameraLookVector * getSettingValue("PcFlySpeed") 
	end
end

local function clearAllTargetIndicatorHighlights()
	for i = #targetIndicators, 1, -1 do
		local Indicator = targetIndicators[i]
		if Indicator.IndicatorObj then
			Indicator.IndicatorObj:Destroy()
		end
		table.remove(targetIndicators, i)
	end
end

local function addTargetIndicatorHighlight(Closest)
	local Existing = Closest.Parent:FindFirstChild("TargetIndicator")
	if Existing then
		local aimbotTargetIndicators = getSettingValue("AimbottargetIndicators")
		if not aimbotTargetIndicators then
			clearAllTargetIndicatorHighlights()
		end
		return
	end
	local TargetIndicator = Instance.new("Highlight")
	TargetIndicator.Name = "TargetIndicator"
	TargetIndicator.FillColor = Color3.new(1, 0, 0)
	TargetIndicator.FillTransparency = 0.5
	TargetIndicator.OutlineColor = Color3.new(1, 0, 0)
	TargetIndicator.OutlineTransparency = 0
	TargetIndicator.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
	TargetIndicator.Parent = Closest.Parent
	table.insert(targetIndicators, {IndicatorObj = TargetIndicator, Target = Closest.Parent})
end

local playerCache = {}
local lastCacheUpdate = 0
local cacheUpdateInterval = 0.1

local function getClosestTargets(count)
	local currentTime = tick()
	
	if currentTime - lastCacheUpdate >= cacheUpdateInterval then
		table.clear(playerCache)
		
		for _, Player in pairs(players:GetPlayers()) do
			if Player.Name ~= localPlayer.Name and Player.Character then
				local Humanoid = Player.Character:FindFirstChild("Humanoid")
				local Head = Player.Character:FindFirstChild("Head")

				if Humanoid and Head and Humanoid.Health > 0 and not Player.Character:FindFirstChild("ProtectionHighlight") then
					local Distance = (Head.Position - localHead.Position).Magnitude

					table.insert(playerCache, {
						Character = Player.Character,
						Head = Head,
						Distance = Distance,
						Player = Player
					})
				end
			end
		end
		
		table.sort(playerCache, function(a, b) return a.Distance < b.Distance end)
		lastCacheUpdate = currentTime
	end

	local Result = {}
	for i = 1, math.min(count, #playerCache) do
		Result[i] = playerCache[i]
	end

	return Result
end

local function getTarget()
	local targets = getClosestTargets(1)
	return targets[1] and targets[1].Character or nil
end

local aimbotOffsetSet = false
local aimbotOffset = nil
local appliedTargetIndicator = false
local destroyedAllIndicators = false

local function addTargetIndicator(Closest)
	if destroyedAllIndicators then destroyedAllIndicators = false end
	if not appliedTargetIndicator then
		addTargetIndicatorHighlight(Closest)
		appliedTargetIndicator = true
	end
end

local function cleartargetIndicators()
	if not destroyedAllIndicators then
		clearAllTargetIndicatorHighlights()
		targetIndicators = {}
		destroyedAllIndicators = true
	end
end

local validTr = {}
local lastFovUpdateTimer = 0

local function updateSize(FOV)
	if FOV then
		FOV.Size = Vector3.new(getSettingValue("LineLength"), getSettingValue("AimbotFov"), getSettingValue("AimbotFov"))
	end
end

local function calculateAimbotRandomization(targetPart)
	if not getSettingValue("AimbotRandomization") then
		tempVector3 = Vector3.new(0, 0, 0)
		return tempVector3
	end

	local multiplier = getSettingValue("RandomizationMultiplier") or 0.8
	local size = targetPart.Size

	local rx = (math.random() - 0.5) * size.X * multiplier * 0.3
	local ry = (math.random() - 0.5) * size.Y * multiplier * 0.3
	local rz = (math.random() - 0.5) * size.Z * multiplier * 0.3

	tempVector3 = (targetPart.CFrame.RightVector * rx) +
	              (targetPart.CFrame.UpVector * ry) +
	              (targetPart.CFrame.LookVector * rz)

	return tempVector3
end

local function checkHitchance(hitchanceValue)
	return math.random(1, 100) <= hitchanceValue
end

local cachedPlayers = {}
local lastPlayerCacheUpdate = 0
local playerCacheInterval = 0.05
local MAX_CACHE_SIZE = 50

local tempVector3 = Vector3.new()
local tempCFrame = CFrame.new()
local tempTable = {}

local CACHED_STRINGS = {
	localPlayerName = localPlayerName,
	targetPartName = nil
}

local function addToCache(cache, item, maxSize)
	if #cache >= maxSize then
		table.remove(cache, 1)
	end
	table.insert(cache, item)
end

local function updatePlayerCache()
	local currentTime = tick()
	if currentTime - lastPlayerCacheUpdate >= playerCacheInterval then
		table.clear(cachedPlayers)
		local playerList = players:GetPlayers()

		local maxIterations = math.min(#playerList, MAX_CACHE_SIZE)

		for i = 1, maxIterations do
			local player = playerList[i]
			if player and player.Name ~= CACHED_STRINGS.localPlayerName and player.Character then
				local humanoid = player.Character:FindFirstChild("Humanoid")
				if humanoid and humanoid.Health > 0 then
					addToCache(cachedPlayers, {
						player = player,
						character = player.Character,
						humanoid = humanoid,
						head = player.Character:FindFirstChild("Head"),
						torso = player.Character:FindFirstChild("Torso")
					}, MAX_CACHE_SIZE)
				end
			end
		end
		lastPlayerCacheUpdate = currentTime
	end
end

local function performantAimbotScan(fovPart, armPart, targetPartName)
	local size = getSettingValue("AimbotFov")
	fovPart.Size = Vector3.new(getSettingValue("LineLength"), 0.005, 0.005)

	local p1 = (fovPart.CFrame.RightVector * (500 - size/2)) + fovPart.Position
	local p2 = (fovPart.CFrame.RightVector * (-500 - size/2)) + fovPart.Position

	local raycastParams = RaycastParams.new()
	raycastParams.FilterType = Enum.RaycastFilterType.Exclude
	raycastParams:AddToFilter(localCharacter)
	raycastParams:AddToFilter(fovPart)

	local spherecastParams = RaycastParams.new()
	spherecastParams.FilterType = Enum.RaycastFilterType.Include

	for _, playerData in ipairs(cachedPlayers) do
		local targetPart = playerData[targetPartName:lower()]
		if targetPart then
			spherecastParams:AddToFilter(targetPart)
		end
	end

	local direction = p2 - p1
	local lengthCheck = workspace:Raycast(p1, direction, raycastParams)

	if lengthCheck then
		direction = direction.Unit * lengthCheck.Distance
	end

	local spherecastResult = workspace:Spherecast(p1, size/2, direction, spherecastParams)

	if spherecastResult then
		return spherecastResult.Instance
	end

	return nil
end

local validTr = {}
local lastFovUpdateTimer = 0

local function executeAimbot(arm, fov, validTargets, lastUpdateTime, hitchance, performantMode, armName)
	CACHED_STRINGS.targetPartName = getSettingValue("AimbotTargetPart")
	local fovUpdateInterval = getSettingValue("FovUpdateIntervalRL")
	local randomizationEnabled = getSettingValue("AimbotRandomization")
	local lerpEnabled = getSettingValue("AimbotLerp")
	local assistSpeed = getSettingValue("AimAssistSpeed")

	if not checkHitchance(hitchance) then
		return nil, lastUpdateTime
	end

	local Closest = nil

		if performantMode then
			Closest = performantAimbotScan(fov, arm, CACHED_STRINGS.targetPartName)
		else
			updateSize(fov)

			local currentTime = tick()
			if currentTime - lastUpdateTime >= fovUpdateInterval then
				table.clear(validTargets)
				for _, P in pairs(workspace:GetPartsInPart(fov)) do
					if P.Name == CACHED_STRINGS.targetPartName and P.Parent.Name ~= CACHED_STRINGS.localPlayerName then
					local Humanoid = P.Parent:FindFirstChild("Humanoid")
					if Humanoid and Humanoid.Health > 0 then
						table.insert(validTargets, P)
					end
				end
			end
			lastUpdateTime = currentTime
		end

		local MinDist = math.huge
		for _, P in ipairs(validTargets) do
			if P.Parent then
				local diff = P.Position - arm.Position
				local DistSquared = diff.X*diff.X + diff.Y*diff.Y + diff.Z*diff.Z
				if DistSquared < MinDist then
					Closest = P
					MinDist = DistSquared
				end
			end
		end
	end

	return Closest, lastUpdateTime
end

local function aimbotR()
	if not userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2) then
		aimbotOffsetSet = false
		appliedTargetIndicator = false
		cleartargetIndicators()
		return
	end

	if not localRightArm or not aimbotFovR then return end

	local randomizationEnabled = getSettingValue("AimbotRandomization")
	local lerpEnabled = getSettingValue("AimbotLerp")
	local assistSpeed = getSettingValue("AimAssistSpeed")

	local Closest, newTime = executeAimbot(
		localRightArm,
		aimbotFovR,
		validTr,
		lastFovUpdateTimer,
		getSettingValue("RightAimbotHitchance"),
		getSettingValue("RightAimbotPerformantMode"),
		"right"
	)
	lastFovUpdateTimer = newTime

	if Closest and localRightArm then
		addTargetIndicator(Closest)

		local targetPosition = Closest.Position
		if randomizationEnabled then
			targetPosition = targetPosition + calculateAimbotRandomization(Closest)
		end

		if not aimbotOffsetSet and not randomizationEnabled then
			local S = Closest.Size
			aimbotOffset = Vector3.new((math.random() - 0.5) * S.X * 0.5, (math.random() - 0.6) * S.Y * 0.5, (math.random() - 0.5) * S.Z * 0.5)
			aimbotOffsetSet = true
		end

		if not randomizationEnabled then
			targetPosition = targetPosition + aimbotOffset
		end

		local TargetCFrame = CFrame.new(localRightArm.Position, targetPosition) * CFrame.Angles(math.rad(90), 0, 0)
		if lerpEnabled then
			localRightArm.CFrame = localRightArm.CFrame:Lerp(TargetCFrame, assistSpeed)
		else
			localRightArm.CFrame = TargetCFrame
		end
	end
end

local validTrReverse = {}
local lastFovUpdateTimeRReverse = 0

local function aimbotRReverse()
	if not userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2) then
		aimbotOffsetSet = false
		appliedTargetIndicator = false
		cleartargetIndicators()
		return
	end

	if not localRightArm or not aimbotFovR then return end

	updateSize(aimbotFovR)

	if tick() - lastFovUpdateTimeRReverse >= getSettingValue("FovUpdateIntervalRL") then
		table.clear(validTrReverse)
		for _, P in pairs(workspace:GetPartsInPart(aimbotFovR)) do
			if P.Name == getSettingValue("AimbotTargetPart") and P.Parent.Name ~= localPlayerName then
				local Humanoid = P.Parent:FindFirstChild("Humanoid")
				if Humanoid and Humanoid.Health > 0 then
					table.insert(validTrReverse, P)
				end
			end
		end
		lastFovUpdateTimeRReverse = tick()
	end

	local Closest = nil
	local MinDist = math.huge
	for _, P in ipairs(validTrReverse) do
		if P.Parent then
			local Dist = (P.Position - localRightArm.Position).Magnitude
			if Dist < MinDist then
				Closest = P
				MinDist = Dist
			end
		end
	end

	if Closest and localRightArm then
		addTargetIndicator(Closest)
		
		local OriginalDistance = (Closest.Position - localRightArm.Position).Magnitude
		
		local RLineDirection = (localRightArm.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).LookVector
		
		local TargetPosition = localRightArm.Position + (RLineDirection * OriginalDistance)
		local TargetCFrame = CFrame.new(TargetPosition)
		
		if getSettingValue("AimbotLerp") then
			Closest.CFrame = Closest.CFrame:Lerp(TargetCFrame, getSettingValue("AimAssistSpeed"))
		else
			Closest.CFrame = TargetCFrame
		end
	end
end


local validTl = {}
local lastFovUpdateTimeL = 0

local function aimbotL()
	if not userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonL2) then
		aimbotOffsetSet = false
		appliedTargetIndicator = false
		cleartargetIndicators()
		return
	end

	if not localLeftArm or not aimbotFovL then return end

	local randomizationEnabled = getSettingValue("AimbotRandomization")
	local lerpEnabled = getSettingValue("AimbotLerp")
	local assistSpeed = getSettingValue("AimAssistSpeed")

	local Closest, newTime = executeAimbot(
		localLeftArm,
		aimbotFovL,
		validTl,
		lastFovUpdateTimeL,
		getSettingValue("LeftAimbotHitchance"),
		false,
		"left"
	)
	lastFovUpdateTimeL = newTime

	if Closest and localLeftArm then
		addTargetIndicator(Closest)

		local targetPosition = Closest.Position
		if randomizationEnabled then
			targetPosition = targetPosition + calculateAimbotRandomization(Closest)
		end

		if not aimbotOffsetSet and not randomizationEnabled then
			local S = Closest.Size
			aimbotOffset = Vector3.new((math.random() - 0.5) * S.X * 0.5, (math.random() - 0.6) * S.Y * 0.5, (math.random() - 0.5) * S.Z * 0.5)
			aimbotOffsetSet = true
		end

		if not randomizationEnabled then
			targetPosition = targetPosition + aimbotOffset
		end

		local TargetCFrame = CFrame.new(localLeftArm.Position, targetPosition) * CFrame.Angles(math.rad(90), 0, 0)
		if lerpEnabled then
			localLeftArm.CFrame = localLeftArm.CFrame:Lerp(TargetCFrame, assistSpeed)
		else
			localLeftArm.CFrame = TargetCFrame
		end
	end
end

local function bringAllGuns()
    if not localTorso then return end
    local gunCount = 0
    for _, V in pairs(items:GetDescendants()) do
        if V.Name == "Grip" and V:IsA("Part") then
            if vrService.VREnabled and localRightArm then
                localRightArm.CFrame = V.CFrame
            end
            task.wait(0.01)
            local Weld = Instance.new("Weld", localTorso)
            Weld.Part0 = localTorso
            Weld.Part1 = V
            task.delay(0.3, function() Weld:Destroy() end)
            gunCount = gunCount + 1
        end
    end
    if gunCount > 0 then
        notificationLibrary.SendNotification("Brought " .. gunCount .. gunCount == 1 and " item" or " items" .. " to you", "Weapons")
    else
        notificationLibrary.SendNotification("No guns found in the map", "Weapons")
    end
end

local function bringAllGuns2()
    if not localTorso then return end
    local gunCount = 0
    for _, V in pairs(items:GetChildren()) do
        if V:IsA("Model") and V:FindFirstChild("Parts") then
            if V.Parts:FindFirstChild("Grip") then
                if vrService.VREnabled and localRightArm then
                    localRightArm.CFrame = V.Parts.Grip.CFrame
                end
                task.wait(0.01)
                local Weld = Instance.new("Weld", localTorso)
                Weld.Part0 = localTorso
                Weld.Part1 = V.Parts.Grip
                task.delay(0.3, function() Weld:Destroy() end)
                gunCount = gunCount + 1
            end
        end
    end
    if gunCount > 0 then
        notificationLibrary.SendNotification("Brought " .. gunCount .. gunCount == 1 and " item" or " items" .. " to you", "Weapons")
    else
        notificationLibrary.SendNotification("No guns found in the map", "Weapons")
    end
end

local function bringSecretGuns()
	for _, V in pairs(items:GetChildren()) do
		if V.Name == "Streamliner" or V.Name == "Flight Pistol" or V.Name == "Explosive Pistol" or V.Name == "Nuke Pistol" or V.Name == "Super Pistol" or V.Name == "Health Pistol" or V.Name == "Balloon Gun" then
			if V:FindFirstChild("Parts") then
				if V.Parts:FindFirstChild("Grip") then
					if vrService.VREnabled then
						localRightArm.CFrame = V.Parts.Grip.CFrame
					end
					task.wait(0.01)
					local Weld = Instance.new("Weld", localTorso)
					Weld.Part0 = localTorso
					Weld.Part1 = V.Parts.Grip
					task.delay(0.3, function() Weld:Destroy() end)
				end
			end
		end
	end
end

local function bringGoodGuns()
    for _, V in pairs(items:GetChildren()) do
        if V.Name == "Cobra" or V.Name == "G36K" or V.Name == "AK74" or V.Name == "AK-74" or V.Name == "AKM" or V.Name == "Desert Eagle R" or V.Name == "Glock 18" or V.Name == "M82 Barrett" then
            if V:FindFirstChild("Parts") then
                if V.Parts:FindFirstChild("Grip") then
                    if vrService.VREnabled then
                        localRightArm.CFrame = V.Parts.Grip.CFrame
                    end
                    task.wait(0.01)
                    local Weld = Instance.new("Weld", localTorso)
                    Weld.Part0 = localTorso
                    Weld.Part1 = V.Parts.Grip
                    task.delay(0.3, function() Weld:Destroy() end)
                end
            end
        end
    end
end

local function hideGuns()
	if not localTorso then
		return
	end
	
	local gunCount = 0
	for _, V in pairs(items:GetChildren()) do
		if V:IsA("Model") and V:FindFirstChild("Parts") then
			if V.Parts:FindFirstChild("Grip") then
				if vrService.VREnabled and localRightArm then
					localRightArm.CFrame = V.Parts.Grip.CFrame
				end
				task.wait(0.01)
				local gunHolderPart = Instance.new("Part", localTorso)
				gunHolderPart.Transparency = 1
				gunHolderPart.Anchored = true
				gunHolderPart.Name = "Right Arm"
				gunHolderPart.CanCollide = false
				gunHolderPart.Position = localTorso.Position + Vector3.new(0, -32, 0)
				local Weld = Instance.new("Weld", gunHolderPart)
				Weld.Part0 = gunHolderPart
				Weld.Part1 = V.Parts.Grip
				task.delay(0.3, function() gunHolderPart:Destroy() end)
				gunCount = gunCount + 1
			end
		end
	end
	
	if gunCount > 0 then
		notificationLibrary.SendNotification("Hidden " .. gunCount .. gunCount == 1 and " item" or " items", "Weapons")
	else
		notificationLibrary.SendNotification("No guns found in the map", "Weapons")
	end
end

function FreezeAllOtherplayers()
	if not modStates.FreezeAllplayers then
		for _, plr in pairs(players:GetPlayers()) do
			if plr ~= localPlayer and plr.Character then
				for _, part in ipairs(plr.Character:GetDescendants()) do
					if part:IsA("BasePart") and part.Anchored and not part:GetAttribute("WasAnchoredBeforeFreeze") then
						part.Anchored = false
					end
					if part:IsA("BasePart") and part:GetAttribute("WasAnchoredBeforeFreeze") ~= nil then
						part:SetAttribute("WasAnchoredBeforeFreeze", nil)
					end
				end
			end
		end
		return
	end

	for _, plr in pairs(players:GetPlayers()) do
		if plr ~= localPlayer and plr.Character then
			for _, part in ipairs(plr.Character:GetDescendants()) do
				if part:IsA("BasePart") and not part.Anchored then
					part:SetAttribute("WasAnchoredBeforeFreeze", false)
					part.Anchored = true
				elseif part:IsA("BasePart") and part.Anchored and part:GetAttribute("WasAnchoredBeforeFreeze") == nil then
					part:SetAttribute("WasAnchoredBeforeFreeze", true)
				end
			end
		end
	end
end

local function killFarm()
	if userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonA) then
		local Target = getTarget()
		if Target then
			local Head = Target.Head
			localRightArm.CFrame = CFrame.new(Head.Position + Vector3.new(-0.2, 1.25, 0), Head.Position + Vector3.new(-0.2, 0, 0)) * CFrame.Angles(math.rad(90), 0, 0)
			localHead.CFrame = Head.CFrame + CFrame.new(0, -1, 0)
		end
	end
end

local rightLookVector = (localRightArm.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).LookVector
local leftLookVector = (localLeftArm.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).LookVector

local function handFly()
	local success, err = pcall(function()
		if not localLocoSphere then return end
		
		if userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode[getSettingValue("Fly1Bind")]) then
			if getSettingValue("HandFlyR") and localRightArm then
				rightLookVector = (localRightArm.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).LookVector
			end
			if getSettingValue("HandFlyL") and localLeftArm then
				leftLookVector = (localLeftArm.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).LookVector
			end
			local Clv = getSettingValue("HandFlyR") and rightLookVector or getSettingValue("HandFlyL") and leftLookVector
			if Clv then
				localLocoSphere.Velocity = Clv * getSettingValue("FlySpeed") 
			end
		end
	end)
	
	if not success then
		warn("HandFly error:", err)
	end
end

local handFly2LastUpdate = 0
local handFly2Interval = 0.08

local function handFly2()
	local success, err = pcall(function()
		local CurrentTime = tick()
		if CurrentTime - handFly2LastUpdate < handFly2Interval then return end
		handFly2LastUpdate = CurrentTime
		
		if not localCharacter then return end
		
		if userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode[getSettingValue("Fly2Bind")]) then
			local Rlv
			if getSettingValue("HandFlyR") and localRightArm then 
				Rlv = (localRightArm.CFrame * CFrame.Angles(math.rad(-90), 0, 0)).LookVector 
			end
			if getSettingValue("HandFlyL") and localLeftArm then 
				Rlv = (localLeftArm.CFrame * CFrame.Angles(math.rad(90), 0, 0)).LookVector 
			end
			if Rlv then
				for _, D in ipairs(localCharacter:GetDescendants()) do
					if D:IsA("BasePart") and D.Name ~= "Right Arm" and D.Name ~= "Left Arm" and not D:IsA("BodyGyro") then
						local Bp = bodyPositions[D.Name]
						if not Bp then
							Bp = Instance.new("BodyPosition")
							Bp.MaxForce = Vector3.new(1e5, 1e5, 1e5)
							Bp.P = 6000
							Bp.Parent = D 
							bodyPositions[D.Name] = Bp
						end
						Bp.Position = D.Position + Rlv * getSettingValue("FlySpeed") 
					end
				end
			end
		else
			for Pn, Bp in pairs(bodyPositions) do
				if Bp then
					Bp:Destroy()
					bodyPositions[Pn] = nil
				end
			end
		end
	end)
	
	if not success then
		warn("HandFly2 error:", err)
	end
end

local LastHeadFlyPivot = 0

local function headFly()
	if userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonX) then
		if tick() - LastHeadFlyPivot >= 0.02 then
			local Direction = localHead.CFrame.LookVector
			for _,v in pairs(localCharacter:GetChildren()) do
				if v:IsA("BasePart") or v:IsA("Part") then
					v:PivotTo(v:GetPivot() + Direction * getSettingValue("HeadFlySpeed"))
				end
			end
			LastHeadFlyPivot = tick()
		end
	end
end

local function getTsfMoveVec()
	local f = camera.CFrame.LookVector
	local r = camera.CFrame.RightVector
	local u = camera.CFrame.UpVector
	local movevec = (r*ltp.X+f*ltp.Y+u*rtp)*getSettingValue("FlySpeed")*2
	return movevec
end

local function thumbstickFly()
	if not vrService.VREnabled or not rootOrLocoSphere then return end
	workspace.Gravity = 0
	if ltp.Magnitude <= 0 and math.abs(rtp) <= 0.05 then return end
	
	local flySpeed = getSettingValue("FlySpeed")
	local _, headYRotation, _ = localHead.CFrame:ToOrientation()
	
	local headOrientation = CFrame.Angles(0, headYRotation, 0)
	local forwardVector = headOrientation.LookVector
	local rightVector = headOrientation.RightVector
	local upVector = Vector3.new(0, 1, 0)
	
	local movementImpulse = (forwardVector * flySpeed * ltp.Y) + 
	                       (rightVector * flySpeed * ltp.X) + 
	                       (upVector * flySpeed * rtp)
	
	rootOrLocoSphere:ApplyImpulse(movementImpulse)
end

local function thumbstickFly2()
	if not vrService.VREnabled or not rootOrLocoSphere then return end
	workspace.Gravity = 0
	local flySpeed = getSettingValue("FlySpeed")

	local moveDirection = localHumanoid.MoveDirection
	
	if moveDirection.Magnitude > 0 or math.abs(rtp.Y) > 0.05 then
		local targetVelocity = Vector3.new(
			moveDirection.X * flySpeed,
			rtp.Y * flySpeed,
			moveDirection.Z * flySpeed
		)
		
		rootOrLocoSphere.Velocity = targetVelocity
	end
end

local FovVisual = nil

local function createFovVisual()
	local Screengui = Instance.new("ScreenGui", cGui)
	Screengui.Name = "aimbotfov"

	local Fov = Instance.new("Frame", Screengui)
	Fov.BackgroundTransparency = 1
	Fov.AnchorPoint = Vector2.new(0.5, 0.5)

	local Corner = Instance.new("UICorner", Fov)
	Corner.CornerRadius = UDim.new(0.5, 0)

	local Stroke = Instance.new("UIStroke", Fov)
	Stroke.Color = Color3.fromRGB(255, 0, 0)
	Stroke.Thickness = 2
	Stroke.Transparency = 0.5

	return Fov
end

FovVisual = createFovVisual()

local function updateFovCircle()
	if FovVisual then
		local Mouselocation = userInputService:GetMouseLocation()
		local Fovrad = getSettingValue("PcAimbotFov") 
		FovVisual.Position = UDim2.new(0, Mouselocation.X, 0, Mouselocation.Y - game:GetService("GuiService"):GetGuiInset().Y)
		FovVisual.Size = UDim2.new(0, Fovrad * 2, 0, Fovrad * 2)
		local showFov = getSettingValue("ShowFov") or false
		local showFovWhenAiming = getSettingValue("ShowFovWhenAiming") or false
		if showFov then
			FovVisual.Visible = true
		end
		if showFovWhenAiming then
			FovVisual.Visible = userInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2)
		end
		if not showFovWhenAiming and not showFov then
			FovVisual.Visible = false
		end
	end
end

local function getNearestPlayerToMouse()
	local Mouselocation = userInputService:GetMouseLocation()
	local Closestplayer = nil
	local Closestdistance = math.huge
	local Closestcameradist = math.huge
	for _, Plr in pairs(players:GetPlayers()) do
		if Plr.Name ~= localPlayerName and Plr.Character and Plr.Character:FindFirstChild("Head") then
			local Humanoid = Plr.Character:FindFirstChild("Humanoid")
			if Humanoid and Humanoid.Health > 0 then
				local Head = Plr.Character.Head
				local cameradist = (camera.CFrame.Position - Head.Position).Magnitude
				if cameradist < Closestcameradist then
					local Screenpos, Onscreen = camera:WorldToViewportPoint(Head.Position)
					if Onscreen then
						local Dist = (Vector2.new(Screenpos.X, Screenpos.Y) - Mouselocation).Magnitude
						if Dist < getSettingValue("PcAimbotFov") and Dist < Closestdistance then
							Closestcameradist = cameradist
							Closestdistance = Dist
							Closestplayer = Plr
						end
					end
				end
			end
		end
	end
	return Closestplayer
end

local function pcAimbot()
	if FovVisual.Visible then
		updateFovCircle()
	end

	if userInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
		local Plr = getNearestPlayerToMouse()

		if Plr and Plr.Character and Plr.Character:FindFirstChild("Head") then
			camera.CFrame = camera.CFrame:Lerp(CFrame.new(camera.CFrame.Position, Plr.Character.Head.Position), getSettingValue("PcAimbotSpeed"))
		end
	end
end

local function slowFalling()
	if localLocoSphere then
		if localLocoSphere.Velocity.Y < -20 then
			localLocoSphere.Velocity = Vector3.new(-4, -4, -4)
		end
	end
end

local function fullbright()
	lighting.TimeOfDay = "12:00:00"
end

local function powerup(PuType)
	local success, err = pcall(function()
		local Powerup = powerUps:FindFirstChild(PuType)
		if not Powerup then
			notificationLibrary.SendNotification("No " .. PuType .. " powerups found in the map", "Powerups")
			return
		end

		if vrService.VREnabled and localHead and localRightArm then
			local powerupPos = Powerup.Position
			local abovePos = powerupPos + Vector3.new(0, 3, 0)
			local targetHeadCF = CFrame.new(powerupPos)
			local targetArmCF = CFrame.new(powerupPos) * CFrame.Angles(math.rad(90), 0, 0)

			localHead.CFrame = CFrame.new(abovePos)
			localRightArm.CFrame = CFrame.new(abovePos + Vector3.new(0, -1, 0))

			for i = 1, 15 do
				localHead.CFrame = localHead.CFrame:Lerp(targetHeadCF, 0.2)
				localRightArm.CFrame = localRightArm.CFrame:Lerp(targetArmCF, 0.2)
				task.wait()
			end

			task.wait(0.5)
		end
	end)
	if not success then
		warn("Failed to collect powerup: " .. tostring(err))
	end
end

local function rgbColorHelper(Modtype, R, G, B)
	for _, Plr in pairs(game.players:GetPlayers()) do
		if Plr.Name ~= localPlayer.Name and Plr.Character then
			local Char = Plr.Character
			local Traitorcolorcheck = (Plr:GetAttribute("ModeTeam") == "Traitor") and Color3.fromRGB(255, 0, 0) or Color3.fromRGB(R, G, B)
			if Modtype == "nesp" then
				local Nesp = Char:FindFirstChild("nameesp")
				if Nesp then
					local Nesptl = Nesp:FindFirstChildOfClass("TextLabel")
					if Nesptl then
						Nesptl.TextColor3 = Traitorcolorcheck
					end
				end
			elseif Modtype == "chams" then
				local Highlight = Char:FindFirstChild("chamshighlight")
				if Highlight then
					Highlight.FillColor = Traitorcolorcheck
				end
			elseif Modtype == "desp" then
				local Dotbg = Char:FindFirstChild("dotespbg")
				if Dotbg then
					local Dotf = Dotbg:FindFirstChild("dotf")
					if Dotf then
						Dotf.BackgroundColor3 = Traitorcolorcheck
					end
				end
			end
		end
	end
end

local currentGuns = {}
local gunSkinTextures = {}
local lastCurrentGunUpdate = 0

local function getAllGuns()
	local allGuns = {}
	for _, item in pairs(items:GetChildren()) do
		if item:IsA("Model") and item:FindFirstChild("Parts") then
			table.insert(allGuns, item)
		end
	end
	return allGuns
end

local function updateCurrentGuns()
	local currentTime = tick()
	if currentTime - lastCurrentGunUpdate >= 2 then
		table.clear(currentGuns)
		if localCharacter then
			for _, obj in pairs(localCharacter:GetChildren()) do
				if obj:IsA("Tool") then
					local actualGunModel = obj:FindFirstChildOfClass("Model")
					if actualGunModel then
						table.insert(currentGuns, actualGunModel)
					end
				elseif obj:IsA("Model") and obj:FindFirstChild("Parts") then
					table.insert(currentGuns, obj)
				end
			end
		end
		lastCurrentGunUpdate = currentTime
	end
end

local function clearGunTextures()
	for _, texture in pairs(gunSkinTextures) do
		if texture then
			texture:Destroy()
		end
	end
	gunSkinTextures = {}
end

local function setGunSkin(id)
	clearGunTextures()

	local allGuns = getAllGuns()
	for _, currentGun in pairs(allGuns) do
		local function createTexture(face, parent)
			local texture = Instance.new("Texture", parent)
			texture.Texture = id
			texture.Face = face
			table.insert(gunSkinTextures, texture)
		end
		local function createAllGunPartTextures(gunPart)
			if gunPart then
				createTexture(Enum.NormalId.Front, gunPart)
				createTexture(Enum.NormalId.Back, gunPart)
				createTexture(Enum.NormalId.Left, gunPart)
				createTexture(Enum.NormalId.Right, gunPart)
				createTexture(Enum.NormalId.Top, gunPart)
			end
		end
		local parts = currentGun:FindFirstChild("Parts")
		if parts then
			createAllGunPartTextures(parts.Bolt)
			createAllGunPartTextures(parts.Bar)
		else
		end
	end
end

local function setGunSkinColor(color)
	local allGuns = getAllGuns()

	for _, currentGun in ipairs(allGuns) do
		if currentGun then
			local parts = currentGun:FindFirstChild("Parts")
			if parts then
				local function editSurfaceAppearance(gunPart)
					gunPart.Color = color
					gunPart.Material = Enum.Material.Neon
					local surface = gunPart:FindFirstChildOfClass("SurfaceAppearance")
					if surface then
						surface.ColorMap = ""
						surface.Color = color
						surface:Destroy()
					end
				end
				if parts:FindFirstChild("Bolt") then editSurfaceAppearance(parts.Bolt) end
				if parts:FindFirstChild("Bar") then editSurfaceAppearance(parts.Bar) end
				if currentGun.Name == "M4A1" or currentGun.Name == "MK18" or currentGun.Name == "Honey Badger" or currentGun.Name == "M82 Barrett" or currentGun.Name == "AKM" or currentGun.Name == "UZI" then
					if parts:FindFirstChild("Main") then editSurfaceAppearance(parts.Main) end
					if parts:FindFirstChild("Base") then editSurfaceAppearance(parts.Base) end
				end
			else
				local function editPart(p)
					if p:IsA("BasePart") or p:IsA("MeshPart") then
						p.Color = color
						p.Material = Enum.Material.Neon
						local surface = p:FindFirstChildOfClass("SurfaceAppearance")
						if surface then
							surface:Destroy()
						end
					end
				end
				
				for _, child in pairs(currentGun:GetChildren()) do
					editPart(child)
				end
			end
		end
	end
end

local gunRgbPhase = 0
local lastRgbUpdate = 0
local rgbUpdateInterval = 0.016

local function stepGunRgb()
	local currentTime = tick()
	if currentTime - lastRgbUpdate < rgbUpdateInterval then return end
	lastRgbUpdate = currentTime

	gunRgbPhase += 0.007
	local r = math.abs(math.sin(gunRgbPhase))
	local g = math.abs(math.sin(gunRgbPhase + 2))
	local b = math.abs(math.sin(gunRgbPhase + 4))
	local color = Color3.new(r, g, b)

	setGunSkinColor(color)
end

local function setAllWallTransparency()
	local Transparency = getSettingValue("WallTransparency") 
	for _, Obj in pairs(map:GetDescendants()) do
		if Obj:IsA("Part") or Obj:IsA("BasePart") then
			Obj.Transparency = Transparency
		end
	end
end

if not testingInRs then
	configManager.LoadConfig("SETTINGS")
	configManager.LoadConfig("MODSTATES")
	configManager.LoadConfig("ESPCONFIG")
	configManager.LoadConfig("NOTIFICATIONSETTINGS")
	validateSettings()
	if espConfig.RLineColor then settings.RLineColor = espConfig.RLineColor end
	if espConfig.LLineColor then settings.LLineColor = espConfig.LLineColor end
	aimbotFovR.Color = getSettingValue("VRFovColor")
	aimbotFovR.Transparency = getSettingValue("VRFovTransparency")
	aimbotFovL.Color = getSettingValue("VRFovColor")
	aimbotFovL.Transparency = getSettingValue("VRFovTransparency")
end

local function SetStrength()
	if not vrService.VREnabled then return end
    local positional = getSettingValue("PositionalStrength") or 750
    local rotational = getSettingValue("RotationalStrength") or 750
    if localLeftArm and localRightArm and localLeftArm.AlignPosition and localLeftArm.AlignOrientation and localRightArm.AlignPosition and localRightArm.AlignOrientation then
        localLeftArm.AlignPosition.MaxForce = positional
        localLeftArm.AlignOrientation.MaxTorque = rotational
        localRightArm.AlignPosition.MaxForce = positional
        localRightArm.AlignOrientation.MaxTorque = rotational
    end
end

local uiConfig = {
	Movement = {
		{
			section = "Flying",
			elements = {
				{type = "toggle", name = "PC Fly", desc = "Hold Q to fly where you look", state = "PcFlyOn"},
				{type = "toggle", name = "Hand Fly", desc = "Fly in the direction your hand points", state = "HandFlyOn"},
				{type = "toggle", name = "Hand Fly 2", desc = "Different fly method", state = "HandFly2On"},
				{type = "toggle", name = "Thumbstick Fly", desc = "Use thumbsticks to fly around", state = "TSFOn"},
				{type = "toggle", name = "Head Fly", desc = "Fly where you look (X button)", state = "HeadFlyOn"}
			}
		},
		{
			section = "Flying Settings",
			elements = {
				{type = "slider", name = "PC Fly Speed", desc = "How fast you fly on PC", min = 10, max = 200, setting = "PcFlySpeed", increment = 20},
				{type = "slider", name = "VR Fly Speed", desc = "How fast you fly in VR", min = 10, max = 200, setting = "FlySpeed", increment = 10},
				{type = "slider", name = "Head Fly Speed", desc = "Head fly movement speed", min = 1, max = 20, setting = "HeadFlySpeed", increment = 2},
				{type = "button", name = "Right Hand VR Fly", desc = "Use right hand for flying", callback = function() 
					if type(settings.HandFlyR) == "table" then settings.HandFlyR.value = true else settings.HandFlyR = { value = true } end
					if type(settings.HandFlyL) == "table" then settings.HandFlyL.value = false else settings.HandFlyL = { value = false } end
					if type(settings.Fly1Bind) == "table" then settings.Fly1Bind.value = "ButtonR2" else settings.Fly1Bind = { value = "ButtonR2" } end
					if type(settings.Fly2Bind) == "table" then settings.Fly2Bind.value = "ButtonR2" else settings.Fly2Bind = { value = "ButtonR2" } end
				end},
				{type = "button", name = "Left Hand VR Fly", desc = "Use left hand for flying", callback = function() 
					if type(settings.HandFlyL) == "table" then settings.HandFlyL.value = true else settings.HandFlyL = { value = true } end
					if type(settings.HandFlyR) == "table" then settings.HandFlyR.value = false else settings.HandFlyR = { value = false } end
					if type(settings.Fly1Bind) == "table" then settings.Fly1Bind.value = "ButtonL2" else settings.Fly1Bind = { value = "ButtonL2" } end
					if type(settings.Fly2Bind) == "table" then settings.Fly2Bind.value = "ButtonL2" else settings.Fly2Bind = { value = "ButtonL2" } end
				end}
			}
		},
		{
			section = "Physics",
			elements = {
				{type = "toggle", name = "Custom Gravity", desc = "Override the world gravity", state = "GravityChangeOn"},
				{type = "slider", name = "Gravity", desc = "Gravity strength (32 is normal)", min = 1, max = 100, setting = "Gravity", increment = 2}
			}
		},
		{
			section = "Player Movement",
			elements = {
				{type = "toggle", name = "Speed Boost", "Gives you a speed boost", state = "SpeedBoostOn"},
				{type = "toggle", name = "Slow Falling", desc = "Slows your fall speed", state = "SlowFallingOn"},
				{type = "toggle", name = "Jump Power", desc = "Gives you a jump boost", state = "JumpPowerOn"},
				{type = "toggle", name = "Bunny Hop (PC Only)", desc = "Auto-jump when landing", state = "BunnyHopOn"}
			}
		},
		{
			section = "Player Movement Settings",
			elements = {
				{type = "slider", name = "PC Speed Boost", desc = "PC movement speed multiplier", min = 1, max = 150, setting = "PcSpeedBoostSpeed", increment = 5},
				{type = "slider", name = "VR Speed Boost", desc = "VR movement speed cap", min = 1, max = 100, setting = "SpeedBoostMaxSpeed", increment = 5},
				{type = "slider", name = "PC Jump Power", desc = "How high you jump on PC", min = 1, max = 100, setting = "PcJumpPower", increment = 5},
				{type = "slider", name = "VR Jump Power", desc = "How high you jump in VR", min = 1, max = 100, setting = "VRJumpPower", increment = 5}
			}
		}
	},
	Weapons = {
		{
			section = "General",
			elements = {
				{type = "button", name = "Bring All Guns [Force Bring]", desc = "Teleport all weapons to you", callback = function() bringAllGuns() end},
				{type = "button", name = "Bring All Guns [Lighter]", desc = "Bring weapons (less laggy)", callback = function() bringAllGuns2() end},
				{type = "button", name = "Bring All Secret Guns", desc = "Bring secret guns", callback = function() bringSecretGuns() end},
				{type = "button", name = "Bring Good Guns", desc = "Bring some of the best guns in my opinion", callback = function() bringGoodGuns() end}
			}
		},
		{
			section = "Visual",
			elements = {
				{type = "toggle", name = "RGB Gun Skin", desc = "Rainbow color cycling on guns", state = "GunRgbOn"},
				{type = "button", name = "Gold Gun Skin", desc = "Apply gold texture to weapons", callback = function()
					local id = "rbxassetid://113796406"
					updateCurrentGuns()
					setGunSkin(id)
				end},
				{type = "button", name = "Reset Gun Skin", desc = "Remove custom gun textures", callback = function() clearGunTextures() end}
			}
		}
	},
	Combat = {
		{
			section = "PC Combat",
			elements = {
				{type = "toggle", name = "Aimbot (PC)", desc = "Right mouse click", state = "PcAimbotOn"}
			}
		},
		{
			section = "PC Combat Settings",
			elements = {
				{type = "slider", name = "PC Aimbot Speed", desc = "How fast aim locks on", min = 0.01, max = 1, setting = "PcAimbotSpeed", increment = 0.05},
				{type = "slider", name = "PC Aimbot FOV", desc = "Detection radius in pixels", min = 20, max = 1000, setting = "PcAimbotFov", increment = 20}
			}
		},
		{
			section = "VR Combat",
			elements = {
				{type = "toggle", name = "Aimbot (Right Hand)", desc = "Right trigger to aim at targets(FOV)", state = "AimbotROn"},
				{type = "toggle", name = "Aimbot (Left Hand)", desc = "Left trigger to aim at targets(FOV)", state = "AimbotLOn"},
				{type = "toggle", name = "Aimbot (Silent Aim)", desc = "Move target to your crosshair(FOV)", state = "AimbotRReverseOn"}
			}
		},
		{
			section = "VR Combat Settings",
			elements = {
				{type = "slider", name = "VR Aimbot FOV Update Time", desc = "Aimbot FOV Update Time", min = 0, max = 0.5, setting = "FovUpdateIntervalRL", increment = 0.02},
				{type = "slider", name = "Aimbot FOV [Keep Low]", desc = "Aimbot FOV Radius", min = 1, max = 30, setting = "AimbotFov", increment = 0.5},
				{type = "slider", name = "Aimbot Assist Speed", desc = "Aimbot Smoothing", min = 0.05, max = 0.95, setting = "AimAssistSpeed", increment = 0.02},
				{type = "button", name = "VR Aimbot Snap Mode", desc = "Disable Aimbot Smoothing", callback = function() 
					if type(settings.AimbotLerp) == "table" then settings.AimbotLerp.value = false else settings.AimbotLerp = { value = false } end
				end},
				{type = "button", name = "VR Aimbot Assist Mode", desc = "Enable Aimbot Smoothing", callback = function() 
					if type(settings.AimbotLerp) == "table" then settings.AimbotLerp.value = true else settings.AimbotLerp = { value = true } end
				end},
				{type = "toggle", name = "Aimbot Target Indicators", desc = "Highlight current target", state = "AimbottargetIndicators"},
				{type = "button", name = "Target Head", desc = "Aim at enemy heads", callback = function() 
					if type(settings.AimbotTargetPart) == "table" then settings.AimbotTargetPart.value = "Head" else settings.AimbotTargetPart = { value = "Head" } end
				end},
				{type = "button", name = "Target Torso", desc = "Target Torso", callback = function() 
					if type(settings.AimbotTargetPart) == "table" then settings.AimbotTargetPart.value = "Torso" else settings.AimbotTargetPart = { value = "Torso" } end
				end},
				{type = "toggle", name = "Aim Randomization", desc = "Randomizes hit point", setting = "AimbotRandomization", callback = function(v)
					if type(settings.AimbotRandomization) == "table" then
						settings.AimbotRandomization.value = v
					else
						settings.AimbotRandomization = { value = v }
					end
				end},
				{type = "slider", name = "Randomization Multiplier", desc = "How much random offset to add", min = 0.1, max = 2.0, setting = "RandomizationMultiplier", increment = 0.1},
				{type = "slider", name = "Right Hand Hitchance (%)", desc = "Chance to hit with right hand", min = 0, max = 100, setting = "RightAimbotHitchance", increment = 5},
				{type = "slider", name = "Left Hand Hitchance (%)", desc = "Chance to hit with left hand", min = 0, max = 100, setting = "LeftAimbotHitchance", increment = 5},
				{type = "toggle", name = "Right Hand Performant Mode", desc = "Less accurate", setting = "RightAimbotPerformantMode", callback = function(v)
					if type(settings.RightAimbotPerformantMode) == "table" then
						settings.RightAimbotPerformantMode.value = v
					else
						settings.RightAimbotPerformantMode = { value = v }
					end
				end}
			}
		},
	},
	Visuals = {
		{
			section = "Name ESP",
			elements = {
				{type = "toggle", name = "Enabled", desc = "Show player names through walls", espState = "NamesOn", callback = function(v)
					espConfig.NamesOn = v
					if not espConfig.NamesOn then esp.ClearEsp(2) end
				end},
				{type = "rgb", name = "Color", desc = "Name tag text color", espSetting = "NespColor", callback = function(color)
					espConfig.NespColor = color
					rgbColorHelper("nesp", math.floor(color.R*255), math.floor(color.G*255), math.floor(color.B*255))
				end}
			}
		},
		{
			section = "Chams ESP",
			elements = {
				{type = "toggle", name = "Enabled", desc = "Highlight players through walls", espState = "ChamsOn", callback = function(v)
					espConfig.ChamsOn = v
					if not espConfig.ChamsOn then esp.ClearEsp(3) end
				end},
				{type = "rgb", name = "Fill Color", desc = "Player highlight fill color", espSetting = "ChamsColor", callback = function(color)
					espConfig.ChamsColor = color
					esp.ClearEsp(3)
					task.wait(0.1)
					if espConfig.ChamsOn then
						for _, Plr in pairs(players:GetPlayers()) do
							if Plr.Name ~= localPlayerName and Plr.Character then
								esp.CreateChamsHighlight(Plr.Character)
							end
						end
					end
				end},
				{type = "rgb", name = "Outline Color", desc = "Player highlight outline color", espSetting = "ChamsOutlineColor", callback = function(color)
					espConfig.ChamsOutlineColor = color
					esp.ClearEsp(3)
					task.wait(0.1)
					if espConfig.ChamsOn then
						for _, Plr in pairs(players:GetPlayers()) do
							if Plr.Name ~= localPlayerName and Plr.Character then
								esp.CreateChamsHighlight(Plr.Character)
							end
						end
					end
				end},
				{type = "slider", name = "Fill Transparency", desc = "Transparency of the fill", min = 0, max = 1, espSetting = "ChamsFillTransparency", defaultValue = 0.6, increment = 0.05, callback = function(v)
					espConfig.ChamsFillTransparency = v
					if espConfig.ChamsOn then
						for _, Plr in pairs(players:GetPlayers()) do
							if Plr.Name ~= localPlayerName and Plr.Character then
								local Highlight = Plr.Character:FindFirstChild("chamshighlight")
								if Highlight then
									Highlight.FillTransparency = v
								else
									esp.CreateChamsHighlight(Plr.Character)
								end
							end
						end
					end
				end},
				{type = "slider", name = "Outline Transparency", desc = "Transparency of the outline", min = 0, max = 1, espSetting = "ChamsOutlineTransparency", defaultValue = 0.36, increment = 0.05, callback = function(v)
					espConfig.ChamsOutlineTransparency = v
					if espConfig.ChamsOn then
						for _, Plr in pairs(players:GetPlayers()) do
							if Plr.Name ~= localPlayerName and Plr.Character then
								local Highlight = Plr.Character:FindFirstChild("chamshighlight")
								if Highlight then
									Highlight.OutlineTransparency = v
								else
									esp.CreateChamsHighlight(Plr.Character)
								end
							end
						end
					end
				end}
			}
		},
		{
			section = "Other",
			elements = {
				{type = "toggle", name = "Health Bar", desc = "Show health bars on players", state = "HealthBarOn", callback = function(v)
					modStates.HealthBarOn = v
					espConfig.HealthBarOn = v
					if not v then esp.ClearEsp(5) end
				end},
				{type = "toggle", name = "Distance Display", desc = "Show distance to players", state = "DistanceOn", callback = function(v)
					modStates.DistanceOn = v
					espConfig.DistanceOn = v
					if not v then esp.ClearEsp(6) end
				end},
			}
		},
		{
			section = "Environment",
			elements = {
				{type = "toggle", name = "Full Bright", desc = "Remove all darkness and fog", state = "FullbrightOn"},
				{type = "slider", name = "Wall Transparency", desc = "Make walls transparent", min = 0, max = 1, setting = "WallTransparency", increment = 0.1},
				{type = "button", name = "Set Wall Transparency (Laggy)", desc = "Apply wall transparency now", callback = function() setAllWallTransparency() end}
			}
		},
		{
			section = "Aimbot",
			elements = {
				{type = "slider", name = "VR FOV Transparency", desc = "Aimbot FOV Visibility", min = 0, max = 1, setting = "VRFovTransparency", increment = 0.05},
				{type = "rgb", name = "VR FOV Color", desc = "Aimbot FOV Color", setting = "VRFovColor"},
			}
		},
		{
			section = "FOV Circle(PC)",
			elements = {
				{type = "button", name = "Show FOV", desc = "Always show aim circle", callback = function()
					if type(settings.ShowFov) == "table" then
						settings.ShowFov.value = true
					else
						settings.ShowFov = { value = true }
					end
					if type(settings.ShowFovWhenAiming) == "table" then
						settings.ShowFovWhenAiming.value = false
					else
						settings.ShowFovWhenAiming = { value = false }
					end
				end},
				{type = "button", name = "Show FOV When Aiming", desc = "Show circle only when aiming", callback = function()
					if type(settings.ShowFov) == "table" then
						settings.ShowFov.value = false
					else
						settings.ShowFov = { value = false }
					end
					if type(settings.ShowFovWhenAiming) == "table" then
						settings.ShowFovWhenAiming.value = true
					else
						settings.ShowFovWhenAiming = { value = true }
					end
				end},
				{type = "button", name = "Hide FOV", desc = "Never show aim circle", callback = function()
					if type(settings.ShowFov) == "table" then
						settings.ShowFov.value = false
					else
						settings.ShowFov = { value = false }
					end
					if type(settings.ShowFovWhenAiming) == "table" then
						settings.ShowFovWhenAiming.value = false
					else
						settings.ShowFovWhenAiming = { value = false }
					end
				end}
			}
		},
		{
			section = "Hand Lasers",
			elements = {
				{type = "toggle", name = "Right Laser", desc = "Laser on right hand", setting = "RLineVisible"},
				{type = "toggle", name = "Left Laser", desc = "Laser on left hand", setting = "LLineVisible"},
				{type = "rgb", name = "Right Laser Color", desc = "Right hand laser color", setting = "RLineColor", callback = function(color)
					if type(settings.RLineColor) == "table" then
						settings.RLineColor  = color
					else
						settings.RLineColor = { value = color }
					end
					espConfig.RLineColor = color
				end},
				{type = "rgb", name = "Left Laser Color", desc = "Left hand laser color", setting = "LLineColor", callback = function(color)
					if type(settings.LLineColor) == "table" then
						settings.LLineColor  = color
					else
						settings.LLineColor = { value = color }
					end
					espConfig.LLineColor = color
				end}
			}
		},
		{
			section = "Laser Settings",
			elements = {
				{type = "slider", name = "Right Laser Transparency", desc = "Right laser visibility", min = 0, max = 1, setting = "ORLT", increment = 0.1},
				{type = "slider", name = "Left Laser Transparency", desc = "Left laser visibility", min = 0, max = 1, setting = "OLLT", increment = 0.1}
			}
		}
	},
	Overpowered = {
		{
			section = "General",
			elements = {
				{type = "toggle", name = "Kill Farm", desc = "Press A then right trigger", state = "KillFarmOn"},
				{type = "toggle", name = "Freeze Other players", desc = "Freezes other players characters", state = "FreezeAllplayers", callback = function(v)
					modStates.FreezeAllplayers = v
					FreezeAllOtherplayers()
				end}
			}
		},
		{
			section = "Consumables",
			elements = {
				-- {type = "button", name = "Eat All", desc = "Teleport to all food items", callback = function()
				-- 	local CONSUMABLES = { Banana = true, Cheezburger = true, Apple = true }
				-- 	for _, item in pairs(items:GetChildren()) do
				-- 		if CONSUMABLES[item.Name] and item.PrimaryPart then
				-- 			localHead.CFrame = item.PrimaryPart.CFrame
				-- 		end
				-- 	end
				-- end},
				{type = "button", name = "Bring All", desc = "Bring all food to you", callback = function()
					local CONSUMABLES = { Banana = true, Cheezburger = true, Apple = true }
					for _, item in pairs(items:GetChildren()) do
						if CONSUMABLES[item.Name] and item.PrimaryPart then
							if vrService.VREnabled and localRightArm then
								localRightArm.CFrame = item.PrimaryPart.CFrame
							end
							task.wait(0.01)
							local Weld = Instance.new("Weld", localTorso)
							Weld.Part0 = localTorso
							Weld.Part1 = item.PrimaryPart
							task.delay(0.3, function() Weld:Destroy() end)
						end
					end
				end}
			}
		},
		{
			section = "Strength",
			elements = {
				{type = "button", name = "Set Strength", desc = "Apply arm strength settings", callback = SetStrength},
				{type = "slider", name = "Positional Strength", desc = "Arm position strength", min = 0, max = 10000, setting = "PositionalStrength", increment = 50, callback = function(v)
					if type(settings.PositionalStrength) == "table" then
						settings.PositionalStrength.value = v
					else
						settings.PositionalStrength = { value = v }
					end
					SetStrength()
				end},
				{type = "slider", name = "Rotational Strength", desc = "Arm rotation strength", min = 0, max = 10000, setting = "RotationalStrength", increment = 50, callback = function(v)
					if type(settings.RotationalStrength) == "table" then
						settings.RotationalStrength.value = v
					else
						settings.RotationalStrength = { value = v }
					end
					SetStrength()
				end}
			}
		},
		{
			section = "Powerups(broken)",
			elements = {
				{type = "button", name = "Heal", desc = "Grab health powerup", callback = function() powerup("Health") end},
				{type = "button", name = "Armor", desc = "Grab armor powerup", callback = function() powerup("Armor") end},
				{type = "button", name = "Speedboost", desc = "Grab speed powerup", callback = function() powerup("Speed") end},
				{type = "button", name = "Jetpack", desc = "Grab jetpack powerup", callback = function() powerup("Jetpack") end}
			}
		}
	},
	Menu = {
		{
			section = "Notifications",
			elements = {
				{type = "toggle", name = "Notifications Enabled", desc = "Show popup notifications", notifSetting = "Enabled", callback = function(v)
					notificationSettings.Enabled = v
				end},
				{type = "button", name = "Send test notification", desc = "Test the notification system", callback = function()
					notificationLibrary.SendNotification("Test notification", "Test title")
				end},
				{type = "slider", name = "Notification Cooldown", desc = "Time between notifications", min = 0.1, max = 4, notifSetting = "Cooldown", increment = 0.1},
				{type = "slider", name = "Notification Lifetime", desc = "How long notifications stay", min = 0.8, max = 6.5, notifSetting = "MessageLifetime", increment = 0.5},
				{type = "slider", name = "Notification Max", desc = "Max notifications on screen", min = 0, max = 7, notifSetting = "MaxNotifications", increment = 1}
			}
		},
		{
			section = "Others",
			elements = {
				{type = "button", name = "Unload Menu", desc = "Close and cleanup the menu", callback = function()
					_G.UntitledOVRMenu.Unload()
				end}
			}
		}
	},
	Misc = {
		{
			section = "Safety",
			elements = {
				{type = "toggle", name = "Anti-Mod Protection", desc = "Auto-leave if moderator joins", state = "AntiModeratorOn"}
			}
		}
	}
}

local function createUIFromConfig()
	local menuTitleText = menuTitle .. " - " .. subscriptionStateText
	local window = LuneUI:CreateWindow(menuTitleText)
	
	local tabs = {}
	
	for tabName, _ in pairs(uiConfig) do
		tabs[tabName] = window:CreateTab(tabName)
	end
	
	for tabName, sections in pairs(uiConfig) do
		local tab = tabs[tabName]
		
		for _, sectionData in ipairs(sections) do
			local section = tab:CreateSection(sectionData.section)
			
			for _, element in ipairs(sectionData.elements) do
				local currentElement = element
				
			if currentElement.type == "toggle" then
				local default = false
				if currentElement.state then
					default = modStates[currentElement.state]
				elseif currentElement.setting then
					local settingData = settings[currentElement.setting]
					if type(settingData) == "table" and settingData.value ~= nil then
						default = settingData.value
					elseif type(settingData) == "boolean" then
						default = settingData
					end
				elseif currentElement.espState then
					default = espConfig[currentElement.espState]
				elseif currentElement.notifSetting then
					default = notificationSettings[currentElement.notifSetting]
				end
				
				local toggleCallback = currentElement.callback or function(v)
					if currentElement.state then
						modStates[currentElement.state] = v
					elseif currentElement.setting then
						local settingData = settings[currentElement.setting]
						if type(settingData) == "table" then
							settingData.value = v
						else
							settings[currentElement.setting] = { value = v }
						end
					elseif currentElement.espState then
						espConfig[currentElement.espState] = v
					elseif currentElement.notifSetting then
						notificationSettings[currentElement.notifSetting] = v
					end
				end
				
				section:AddToggle(currentElement.name, currentElement.desc or "", default, toggleCallback)
					
			elseif currentElement.type == "slider" then
				local default = 0
				local min = currentElement.min
				local max = currentElement.max
				
				if currentElement.setting then
					local settingData = settings[currentElement.setting]
					if type(settingData) == "table" then
						default = settingData.value or 0
						min = min or settingData.min or 0
						max = max or settingData.max or 100
					else
						default = settingData or 0
					end
				elseif currentElement.espSetting then
					default = espConfig[currentElement.espSetting] or currentElement.defaultValue or 0
					min = min or 0
					max = max or 1
				elseif currentElement.notifSetting then
					default = notificationSettings[currentElement.notifSetting]
					min = min or 0
					max = max or 10
				end
				
				local sliderCallback
				if type(currentElement.callback) == "function" then
					sliderCallback = currentElement.callback
				else
					sliderCallback = function(v)
						if currentElement.setting then
							local settingData = settings[currentElement.setting]
							if type(settingData) == "table" then
								settingData.value = v
							else
								settings[currentElement.setting] = { value = v }
							end
						elseif currentElement.espSetting then
							espConfig[currentElement.espSetting] = v
						elseif currentElement.notifSetting then
							notificationSettings[currentElement.notifSetting] = v
						end
					end
				end
				
				section:AddSlider({
					Title = currentElement.name,
					Min = min,
					Max = max,
					Value = default,
					Increment = currentElement.increment or 1,
					Callback = sliderCallback
				})
					
				elseif currentElement.type == "button" then
					section:AddButton(currentElement.name, currentElement.desc or "", currentElement.callback)
					
			elseif currentElement.type == "rgb" then
				local default = Color3.new(1, 1, 1)
				if currentElement.setting then
					local settingData = settings[currentElement.setting]
					if type(settingData) == "table" and settingData.value then
						default = settingData.value
					elseif typeof(settingData) == "Color3" then
						default = settingData
					end
				elseif currentElement.espSetting then
					default = espConfig[currentElement.espSetting]
				end
				
				local rgbCallback = currentElement.callback or function(color)
					if currentElement.setting then
						local settingData = settings[currentElement.setting]
						if type(settingData) == "table" then
							settingData.value = color
						else
							settings[currentElement.setting] = { value = color }
						end
					elseif currentElement.espSetting then
						espConfig[currentElement.espSetting] = color
					end
				end
				
				section:AddColorPicker(currentElement.name, currentElement.desc or "", default, rgbCallback)
				end
			end
		end
	end
	
	return window, menuTitleText
end

local window, menuTitleText = createUIFromConfig()

SetStrength()

_G.UntitledOVRMenu.Unload = function()
	timedLoopModule.UnbindFromLoop("SaveConfig")

    task.wait(1)

    for key, _ in pairs(modStates) do
        modStates[key] = false
    end

    timedLoopModule.UnbindFromLoop("MainHeartbeat")
    timedLoopModule.UnbindFromLoop("LaserTransparencyHandler")
    timedLoopModule.UnbindFromLoop("TargetIndicatorCleanup")

    clearAllTargetIndicatorHighlights()
    table.clear(targetIndicators)
    table.clear(validTr)
    table.clear(validTl)
	table.clear(validTrReverse)

    if aimbotFovR then
        aimbotFovR:Destroy()
    end
    if aimbotFovL then
        aimbotFovL:Destroy()
    end
    if rLine then
        rLine:Destroy()
    end
    if lLine then
        lLine:Destroy()
    end
    if FovVisual and FovVisual.Parent then
        FovVisual:Destroy()
    end

    lighting.FogEnd = 100000
    lighting.FogStart = 30
    lighting.Brightness = 1
    lighting.GlobalShadows = true
    workspace.Gravity = 32

    if localHumanoid and not vrService.VREnabled then
    	localHumanoid.JumpPower = 16
    end

    for name, bp in pairs(bodyPositions) do
        if bp then
            bp:Destroy()
        end
        bodyPositions[name] = nil
    end

    esp.ClearEsp(2)
    esp.ClearEsp(3)
    esp.ClearEsp(4)

    notificationLibrary.SendNotification("Script unloaded.", "Script")
    task.wait(0.5)

	if window and window.MainFrame then
		window.Destroy()
	end
    timedLoopModule.Destroy()
end

local LastInputTime = 0
local InputCooldown = 1.5
local function toggleMenu()
	local CT = tick()
	if CT - LastInputTime < InputCooldown then return end
	LastInputTime = CT
	if window and window.MainFrame then
		window.MainFrame.Visible = not window.MainFrame.Visible
	end
end

userInputService.InputBegan:Connect(function(Input)
	if Input.UserInputType == Enum.UserInputType.Gamepad1 then
		if Input.KeyCode == Enum.KeyCode.ButtonX then
			toggleMenu()
		end
	end
	if Input.KeyCode == Enum.KeyCode.V then
		toggleMenu()
	end
end)

local removedBodyPositions = false
local setFullbrightLighting = false
local frameCounter = 0

local function safeExecute(func, funcName)
	local success, err = pcall(func)
	if not success then
		warn(funcName .. " error:", err)
		return false
	end
	return true
end

local function memoryCleanup()
	table.clear(tempTable)
end

timedLoopModule.BindToLoop("MainHeartbeat", false, 0, function()
	frameCounter = frameCounter + 1

	local success, err = pcall(function()
		updatePlayerCache()

		if modStates.AimbotROn then
			aimbotR()
		end
		if modStates.AimbotLOn then
			aimbotL()
		end
		if modStates.KillFarmOn then
			killFarm()
		end
		if modStates.HandFlyOn then
			handFly()
		end

		if modStates.SpeedBoostOn then
			speedBoost()
		end
		if modStates.PcAimbotOn then
			pcAimbot()
			updateFovCircle()
		else
			if FovVisual then
				FovVisual.Visible = false
			end
		end
		if modStates.PcFlyOn then
			pcFly()
		end
		if modStates.SlowFallingOn then
			slowFalling()
		end
		if modStates.JumpPowerOn then
			jumpPower()
		else
			if localHumanoid then
				if localHumanoid.JumpPower ~= 16 and not vrService.VREnabled then
					localHumanoid.JumpPower = 16
				end
			end
		end

		if frameCounter % 3 == 0 then
			if modStates.HandFly2On then
				handFly2()
				removedBodyPositions = false
			else
				if not removedBodyPositions then
					removedBodyPositions = true
					task.wait(0.5)
					for name, bp in pairs(bodyPositions) do
						if bp then
							bp:Destroy()
							bodyPositions[name] = nil
						end
					end
				end
			end

			if modStates.BunnyHopOn then
				bunnyHop()
			else
				stopbunnyHop()
			end

			if modStates.GravityChangeOn then
				workspace.Gravity = getSettingValue("Gravity")
			else
				workspace.Gravity = 32
			end
		end

		if frameCounter % 7 == 0 then
			esp.UpdateAllEsp()
			if modStates.GunRgbOn then
				stepGunRgb()
			end
		end

		if modStates.FullbrightOn then
			fullbright()
			if not setFullbrightLighting then
				setFullbrightLighting = true
				lighting.FogEnd, lighting.FogStart, lighting.ClockTime, lighting.Brightness, lighting.GlobalShadows = 999999, 0, 14, 2, false
				local atmosphere = lighting["Atmosphere"]
				if atmosphere then atmosphere.Density = 0 end
			end
		else
			if setFullbrightLighting then
				setFullbrightLighting = false
				lighting.FogEnd, lighting.FogStart, lighting.Brightness, lighting.GlobalShadows = 100000, 30, 1, true
			end
		end

		if frameCounter % 5 == 0 then
			if modStates.TSFOn then
				thumbstickFly()
			end
			if modStates.HeadFlyOn then
				headFly()
			end
			if modStates.AimbotRReverseOn then
				aimbotRReverse()
			end
		end

		memoryCleanup()

		if frameCounter >= 60 then
			frameCounter = 0
		end
	end)

	if not success then
		warn("MainHeartbeat error:", err)
	end
end)

timedLoopModule.BindToLoop("AntiModeratorCheck", false, 5, function()
	if not modStates.AntiModeratorOn then return end
	for _, player in pairs(players:GetPlayers()) do
        local moderatorList = getSettingValue("ModeratorList") or {}
        for _, modName in pairs(moderatorList) do
            if player.Name == modName then
                notificationLibrary.SendNotification("A moderator was detected inside of this server, Auto-leaving now.", "Anti-Mod")
                task.wait(3.2)
                localPlayer:Kick(" mo-der-ator de-tec-ted ")
            end
        end
    end
end)

timedLoopModule.BindToLoop("LaserTransparencyHandler", false, 0.2, function()
	local success, err = pcall(function()
		if rLine then
			local rColor = type(settings.RLineColor) == "table" and settings.RLineColor.value or (typeof(settings.RLineColor) == "Color3" and settings.RLineColor or Color3.new(1, 0, 0))
			rLine.Color = rColor
			local rVisible = getSettingValue("RLineVisible") or false
			if rVisible then
				rLine.Transparency = getSettingValue("ORLT") or 0.3
			else
				rLine.Transparency = 1
			end
		end
		if lLine then
			local lColor = type(settings.LLineColor) == "table" and settings.LLineColor.value or (typeof(settings.LLineColor) == "Color3" and settings.LLineColor or Color3.new(1, 0, 0))
			lLine.Color = lColor
			local lVisible = getSettingValue("LLineVisible") or false
			if lVisible then
				lLine.Transparency = getSettingValue("OLLT") or 0.3
			else
				lLine.Transparency = 1
			end
		end
		
		if aimbotFovR then
			aimbotFovR.Transparency = getSettingValue("VRFovTransparency") or 0.7
			aimbotFovR.Color = getSettingValue("VRFovColor") or Color3.fromRGB(255, 0, 0)
		end
		if aimbotFovL then
			aimbotFovL.Transparency = getSettingValue("VRFovTransparency") or 0.7
			aimbotFovL.Color = getSettingValue("VRFovColor") or Color3.fromRGB(255, 0, 0)
		end
	end)
	
	if not success then
		warn("LaserTransparencyHandler error:", err)
	end
end)

timedLoopModule.BindToLoop("TargetIndicatorCleanup", false, 2, function()
	local success, err = pcall(function()
		if not getSettingValue("AimbottargetIndicators") then
			clearAllTargetIndicatorHighlights()
		end
	end)
	
	if not success then
		warn("TargetIndicatorCleanup error:", err)
	end
end)

timedLoopModule.BindToLoop("SaveConfig", false, 2.5, function()
	local success, err = pcall(function()
		configManager.SaveConfig("SETTINGS")
		configManager.SaveConfig("MODSTATES")
		configManager.SaveConfig("ESPCONFIG")
		configManager.SaveConfig("NOTIFICATIONSETTINGS")
	end)
	
	if not success then
		warn("SaveConfig error:", err)
	end
end)

local function UpdateCharacterReferences(Char)
	local success, err = pcall(function()
		if not vrService.VREnabled then
			task.wait(2.5)
			localCharacter = Char
			localHumanoid = Char:FindFirstChild("Humanoid")
			localHead = Char:FindFirstChild("Head")
			localTorso = Char:FindFirstChild("Torso")
			localRoot = Char:FindFirstChild("Root") or Char:FindFirstChild("HumanoidRootPart")
			localLocoSphere = localCharacter:FindFirstChild("LocoSphere") or localCharacter:FindFirstChild("HumanoidRootPart")
			localRightArm = Char:FindFirstChild("Right Arm")
			localLeftArm = Char:FindFirstChild("Left Arm")
			rootOrLocoSphere = localCharacter:FindFirstChild("Root") or localCharacter:FindFirstChild("HumanoidRootPart") or localCharacter:FindFirstChild("LocoSphere")
			
			table.clear(playerCache)
			lastCacheUpdate = 0
		end
	end)
	
	if not success then
		warn("UpdateCharacterReferences error:", err)
	end
end

localPlayer.CharacterAdded:Connect(UpdateCharacterReferences)
localCharacter = localPlayer.Character or localPlayer.CharacterAdded:Wait()
UpdateCharacterReferences(localCharacter)

userInputService.InputChanged:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		ltp = Vector2.new(input.Position.X, input.Position.Y)
	end
	if input.KeyCode == Enum.KeyCode.Thumbstick2 then
		rtp = input.Position.Y
	end
end)

userInputService.InputEnded:Connect(function(input)
	if input.KeyCode == Enum.KeyCode.Thumbstick1 then
		ltp = Vector2.new(0, 0)
	elseif input.KeyCode == Enum.KeyCode.Thumbstick2 then
		rtp = 0
	end
end)


if getSettingValue("WallTransparency") > 0 then setAllWallTransparency() end
